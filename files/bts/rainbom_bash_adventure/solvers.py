import time
import random
from typing import List, Tuple
import numpy as np


# Generated by claude for testing
class GeneticTSP:
    def __init__(self, distance_matrix: np.ndarray, population_size: int = 100, 
                 mutation_rate: float = 0.05, elitism_rate: float = 0.1):
        """
        Initialize the Genetic Algorithm TSP solver.
        
        Args:
            distance_matrix: Square matrix where distance_matrix[i][j] is distance from city i to j
            population_size: Number of individuals in the population
            mutation_rate: Probability of mutation for each gene
            elitism_rate: Proportion of best individuals to keep unchanged
        """
        self.distance_matrix = distance_matrix
        self.num_cities = distance_matrix.shape[0]
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.elitism_count = max(1, int(population_size * elitism_rate))
        
        # Initialize population with random permutations
        self.population = [self._random_route() for _ in range(population_size)]
        self.best_route = None
        self.best_distance = float('inf')
        
    def _random_route(self) -> List[int]:
        """Generate a random route (permutation of cities)."""
        route = list(range(self.num_cities))
        random.shuffle(route)
        return route
    
    def _calculate_fitness(self, route: List[int]) -> float:
        """Calculate the fitness of a route (inverse of total distance)."""
        distance = 0
        for i in range(self.num_cities):
            from_city = route[i]
            to_city = route[(i + 1) % self.num_cities]
            distance += self.distance_matrix[from_city][to_city]
        
        # Return inverse of distance (higher is better)
        return 1.0 / distance if distance > 0 else float('inf')
    
    def _calculate_distance(self, route: List[int]) -> float:
        """Calculate the total distance of a route."""
        distance = 0
        for i in range(self.num_cities):
            from_city = route[i]
            to_city = route[(i + 1) % self.num_cities]
            distance += self.distance_matrix[from_city][to_city]
        return distance
    
    def _selection(self) -> List[List[int]]:
        """Select individuals for breeding using tournament selection."""
        tournament_size = 3
        selected = []
        
        # Calculate fitness for each individual
        fitness_values = [self._calculate_fitness(route) for route in self.population]
        
        # Elitism: keep the best individuals
        elite_indices = np.argsort(fitness_values)[-self.elitism_count:]
        for idx in elite_indices:
            selected.append(self.population[idx])
        
        # Tournament selection for the rest
        while len(selected) < self.population_size:
            tournament = random.sample(range(self.population_size), tournament_size)
            tournament_fitness = [fitness_values[i] for i in tournament]
            winner_idx = tournament[tournament_fitness.index(max(tournament_fitness))]
            selected.append(self.population[winner_idx])
        
        return selected
    
    def _crossover(self, parent1: List[int], parent2: List[int]) -> List[int]:
        """Create a child using Ordered Crossover (OX)."""
        size = self.num_cities
        
        # Choose random start/end points for crossover
        start, end = sorted(random.sample(range(size), 2))
        
        # Initialize child with -1s
        child = [-1] * size
        
        # Copy segment from parent1
        child[start:end+1] = parent1[start:end+1]
        
        # Fill remaining positions with cities from parent2 (in order)
        parent2_remaining = [city for city in parent2 if city not in child]
        
        # Fill from the end of the segment to the end of the child
        for i in range(end + 1, size):
            child[i] = parent2_remaining.pop(0)
        
        # Fill from the beginning to the start of the segment
        for i in range(start):
            child[i] = parent2_remaining.pop(0)
            
        return child
    
    def _mutate(self, route: List[int]) -> List[int]:
        """Apply swap mutation to a route."""
        if random.random() < self.mutation_rate:
            idx1, idx2 = random.sample(range(self.num_cities), 2)
            route[idx1], route[idx2] = route[idx2], route[idx1]
        return route
    
    def _breed_population(self, selected: List[List[int]]) -> List[List[int]]:
        """Create a new population through crossover and mutation."""
        children = selected[:self.elitism_count]  # Keep elite individuals unchanged
        
        # Create remaining children
        while len(children) < self.population_size:
            parent1, parent2 = random.sample(selected, 2)
            child = self._crossover(parent1, parent2)
            child = self._mutate(child)
            children.append(child)
            
        return children
    
    def _update_best_route(self):
        """Update the best route found so far."""
        for route in self.population:
            distance = self._calculate_distance(route)
            if distance < self.best_distance:
                self.best_distance = distance
                self.best_route = route.copy()
    
    def solve(self, max_time_seconds: float, verbose: bool = True) -> Tuple[List[int], float]:
        """
        Solve the TSP problem using genetic algorithm with a time limit.
        
        Args:
            max_time_seconds: Maximum execution time in seconds
            verbose: Whether to print progress information
            
        Returns:
            Tuple containing the best route found and its distance
        """
        start_time = time.time()
        generation = 0
        
        while time.time() - start_time < max_time_seconds:
            # Perform one generation of the genetic algorithm
            selected = self._selection()
            self.population = self._breed_population(selected)
            self._update_best_route()
            
            generation += 1
            
            # Print progress every 10 generations
            if verbose and generation % 10 == 0:
                elapsed = time.time() - start_time
                print(f"Generation {generation}, Best distance: {self.best_distance:.2f}, Time: {elapsed:.2f}s")
        
        total_time = time.time() - start_time
        if verbose:
            print(f"\nFinished after {generation} generations ({total_time:.2f} seconds)")
            print(f"Best route: {self.best_route}")
            print(f"Distance: {self.best_distance}")
            
        return self.best_route, self.best_distance



def greedy_tsp_solver(distance_matrix: np.ndarray, 
                      start_city = None,
                      max_time_seconds: float = float('inf'),
                      verbose: bool = True) -> Tuple[List[int], float]:
    """
    Solves the Traveling Salesman Problem using a greedy nearest neighbor approach.
    
    Args:
        distance_matrix: Square matrix where distance_matrix[i][j] is distance from city i to j
        start_city: Index of starting city (random if None)
        max_time_seconds: Maximum execution time in seconds
        verbose: Whether to print progress information
        
    Returns:
        Tuple containing the best route found and its distance
    """
    start_time = time.time()
    num_cities = distance_matrix.shape[0]
    
    # If no start city is provided, try all possible starting cities
    # (within the time limit) and keep the best result
    if start_city is None:
        best_route = None
        best_distance = float('inf')
        
        for city in range(num_cities):
            # Check if we still have time
            if time.time() - start_time >= max_time_seconds:
                if verbose:
                    print(f"Time limit reached after exploring {city} starting cities")
                break
                
            route, distance = greedy_nearest_neighbor(distance_matrix, city)
            
            if distance < best_distance:
                best_distance = distance
                best_route = route
                
                if verbose:
                    elapsed = time.time() - start_time
                    print(f"New best route from start city {city}: {distance:.2f} (Time: {elapsed:.2f}s)")
        
        total_time = time.time() - start_time
        if verbose:
            print(f"\nFinished in {total_time:.2f} seconds")
            print(f"Best route: {best_route}")
            print(f"Distance: {best_distance}")
            
        return best_route, best_distance
    else:
        # Just run the algorithm with the specified start city
        route, distance = greedy_nearest_neighbor(distance_matrix, start_city)
        
        total_time = time.time() - start_time
        if verbose:
            print(f"\nFinished in {total_time:.2f} seconds")
            print(f"Route from city {start_city}: {route}")
            print(f"Distance: {distance}")
            
        return route, distance


def greedy_nearest_neighbor(distance_matrix: np.ndarray, start_city: int) -> Tuple[List[int], float]:
    """
    Builds a route using the nearest neighbor algorithm from a specified starting city.
    
    Args:
        distance_matrix: Square matrix where distance_matrix[i][j] is distance from city i to j
        start_city: Index of the starting city
        
    Returns:
        Tuple containing the route and its total distance
    """
    num_cities = distance_matrix.shape[0]
    unvisited = set(range(num_cities))
    unvisited.remove(start_city)
    
    route = [start_city]
    current_city = start_city
    total_distance = 0
    
    # Visit each city in order of closest to current position
    while unvisited:
        # Get distances from current city to all unvisited cities
        distances = [(city, distance_matrix[current_city, city]) for city in unvisited]
        
        # Find closest unvisited city
        next_city, distance = min(distances, key=lambda x: x[1])
        
        # Add to route and update total distance
        route.append(next_city)
        total_distance += distance
        
        # Update current position and unvisited set
        current_city = next_city
        unvisited.remove(next_city)
    
    # Add return to starting city to complete the tour
    total_distance += distance_matrix[route[-1], start_city]
    
    return route, total_distance
