<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Linux Internals: How ASLR REALLY works | poni’s blog</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Linux Internals: How ASLR REALLY works" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Linux Internals: How ASLR REALLY works" />
<meta property="og:description" content="Linux Internals: How ASLR REALLY works" />
<link rel="canonical" href="https://poniponiponiponiponiponiponiponiponi.github.io/c/linux/alsr/2025/06/13/Linux-Internals-How-ASLR-REALLY-Works.html" />
<meta property="og:url" content="https://poniponiponiponiponiponiponiponiponi.github.io/c/linux/alsr/2025/06/13/Linux-Internals-How-ASLR-REALLY-Works.html" />
<meta property="og:site_name" content="poni’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-06-13T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Linux Internals: How ASLR REALLY works" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-06-13T00:00:00+00:00","datePublished":"2025-06-13T00:00:00+00:00","description":"Linux Internals: How ASLR REALLY works","headline":"Linux Internals: How ASLR REALLY works","mainEntityOfPage":{"@type":"WebPage","@id":"https://poniponiponiponiponiponiponiponiponi.github.io/c/linux/alsr/2025/06/13/Linux-Internals-How-ASLR-REALLY-Works.html"},"url":"https://poniponiponiponiponiponiponiponiponi.github.io/c/linux/alsr/2025/06/13/Linux-Internals-How-ASLR-REALLY-Works.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://poniponiponiponiponiponiponiponiponi.github.io/feed.xml" title="poni&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">poni&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Linux Internals: How ASLR *REALLY* works</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-06-13T00:00:00+00:00" itemprop="datePublished">Jun 13, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="linux-internals-how-aslr-really-works">Linux Internals: How ASLR <em>REALLY</em> works</h1>

<h2 id="introduction">Introduction</h2>
<p>Nowadays, the security of our programs doesn’t depend solely on the
programmer. Modern compilers and operating systems like Linux and
Windows implement various mitigations to make it harder for attackers
to exploit vulnerabilities - one such mitigation is Address Space
Layout Randomization, commonly known as ASLR. In this article, we’ll
explore not just the basics but also, thanks to open-source, examine
under the hood how each random base address is determined. We’ll also
see that no implementation is perfect, as developers implementing such
solutions must balance security, speed, and simplicity.</p>

<h2 id="quick-demonstration">Quick Demonstration</h2>
<p>Wikipedia tells us: “Address Space Layout Randomization is a computer
security technique used to prevent exploitation of memory corruption
vulnerabilities. To prevent an attacker from redirecting code
execution, for example to a specific function in memory, ASLR randomly
arranges key data areas of a process in the address space, including
the base of the executable and the positions of the stack, heap, and
libraries.” While this definition is correct, I believe things are
easiest to explain by showing. Let’s take a simple C program printing
the address of a local variable <code class="language-plaintext highlighter-rouge">c</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>After compiling and running this code multiple times, we can observe
that the variable’s address changes each time. This is thanks to ASLR!</p>

<p><img src="/files/aslr/p1.png" alt="image" /></p>

<p>We can repeat the experiment for variables in different memory
segments: e.g., local, global, and function addresses.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="n">globalna</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">funkcja</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">lokalna</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"lokalna:</span><span class="se">\t</span><span class="s">%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lokalna</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"globalna:</span><span class="se">\t</span><span class="s">%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">globalna</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"funkcja:</span><span class="se">\t</span><span class="s">%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">funkcja</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"printf: </span><span class="se">\t</span><span class="s">%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">printf</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>And the result:</p>

<p><img src="/files/aslr/p2.png" alt="image" /></p>

<p>Observant readers can already spot some imperfections, but let’s not
get ahead of ourselves :).</p>

<h2 id="the-cake---position-independent-executable-pie">The Cake - Position Independent Executable (PIE)</h2>

<p>ASLR presence alone isn’t enough. For an executable to be loaded
anywhere in the virtual address space, it must be compiled in a
special way to be position-independent. The compiler must avoid
absolute addressing and use relative addressing everywhere. Shared
libraries have always been compiled with the assumption they wouldn’t
know their memory location, but historically this wasn’t always true
for executables. For example, let’s take this program and compile it
in different ways:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">global</span> <span class="o">=</span> <span class="mh">0x41</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">global</span> <span class="o">=</span> <span class="mh">0x61</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For x86-64 64-bit systems, compilation method doesn’t matter - both
cases (at least with my gcc 15.1.1) use RIP-relative addressing: <code class="language-plaintext highlighter-rouge">movl
$0x61, 0x2efc(%rip)</code>.</p>

<p><img src="/files/aslr/pie2.png" alt="image" /></p>

<p>For 32-bit x86 systems, things get more interesting. The x86
architecture lacks EIP-relative addressing, so the compiler works
around this differently for PIE binaries. For no-PIE, we know the
variable address. For PIE, the compiler created a special
<code class="language-plaintext highlighter-rouge">__x86.get_pc_thunk.ax</code> function that loads <code class="language-plaintext highlighter-rouge">%eip</code> into <code class="language-plaintext highlighter-rouge">%eax</code> by
reading the return address from the stack.</p>

<p><img src="/files/aslr/pie3.png" alt="image" /></p>

<p><img src="/files/aslr/thunk.png" alt="image" /></p>

<p>Depending on your distro, PIE may be enabled by default or
not. There’s no standard. According to my tests on Fedora and
OpenSUSE, <code class="language-plaintext highlighter-rouge">-pie</code> and <code class="language-plaintext highlighter-rouge">-fpie</code> flags aren’t added automatically. On Arch
(which I use), Gentoo, Ubuntu and Debian, these flags are added
automatically… except when using <code class="language-plaintext highlighter-rouge">-static</code>! For illustration, we’ll
use checksec from pwntools. Compilation with <code class="language-plaintext highlighter-rouge">-static</code> builds without
position-independent code. I’d recommend avoiding this flag and using
<code class="language-plaintext highlighter-rouge">-static-pie</code> instead. We lose nothing but a few CPU cycles during
address randomization, while gaining significant security.</p>

<p><img src="/files/aslr/pie1.png" alt="image" /></p>

<h2 id="linux-internals">Linux Internals</h2>

<p>Żeby zobaczyć eksperymentalnie, nie tylko patrząc na kod i bez
robienia żadnych założeń, jak liczone są wszystkie adresy, zbudowałem
kernel Linuxa z symbolami do debugowania. Podpinając debugger gdb do
kernela uruchomionego w wirtualnej maszynie QEMU zobaczymy od środka
jaki kod się wykonuje i jakie zmienne przyjmują jakie
wartości. Zachęcam do wykonania eksperymentu również u siebie w domu!</p>

<p>To experimentally see (without just reading code or making
assumptions) how addresses are calculated, I built a Linux kernel with
debug symbols. By attaching GDB to the kernel running in QEMU, we’ll
see the executing code and variable’s values. I encourage you to do
this in home!</p>

<h3 id="przygotowanie-środowiska">Przygotowanie środowiska</h3>

<p>The steps that I’ll do are based on:
https://vccolombo.github.io/cybersecurity/linux-kernel-qemu-setup/
. You can skip reading this section if you’re not interested in
replicating the experiment yourself.</p>

<p>First install all the dependencies:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ubuntu</span>
<span class="nb">sudo </span>apt-get update
<span class="nb">sudo </span>apt-get <span class="nb">install </span>git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison qemu-system-x86 debootstrap

<span class="c"># archlinux</span>
<span class="nb">sudo </span>pacman <span class="nt">-S</span> git fakeroot base-devel ncurses xz openssl bc flex libelf bison qemu-system-x86 debootstrap
</code></pre></div></div>

<p>Next, download the latest kernel tarball from https://www.kernel.org/
(6.15-rc7 as of writing), and extract it.</p>

<p><img src="/files/aslr/l1.png" alt="image" /></p>

<p>Wygenerować pliki potrzebne do kompilacji poprzez napisanie <code class="language-plaintext highlighter-rouge">$ make
defconfig</code>, po czym otworzyć plik .config w ulubionym edytorze
tekstowym, w moim przypadku jest to Emacs, i dopisać na koniec:</p>

<p>Generate build files with <code class="language-plaintext highlighter-rouge">$ make defconfig</code>, then edit the <code class="language-plaintext highlighter-rouge">.config</code>
with your favourite (in my case Emacs) to add:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Coverage collection.
CONFIG_KCOV=y

# Debug info for symbolization.
CONFIG_DEBUG_INFO=y

# Memory bug detector
CONFIG_KASAN=y
CONFIG_KASAN_INLINE=y

# Required for Debian Stretch
CONFIG_CONFIGFS_FS=y
CONFIG_SECURITYFS=y

CONFIG_DEBUG_INFO_DWARF5=y
</code></pre></div></div>

<p>After that, run $ make olddefconfig then compile with <code class="language-plaintext highlighter-rouge">$ make
-j$(nproc)</code>. This may take 10 minutes to several hours.</p>

<p><img src="/files/aslr/l2.png" alt="image" /></p>

<p>If you’ve never compiled a kernel before, as you can see it’s not
nearly as scary as it might seem! After the compilation is done, two
files should be created: <code class="language-plaintext highlighter-rouge">./vmlinux</code> which is the kernel file with
debugging symbols and <code class="language-plaintext highlighter-rouge">arch/x86_64/boot/bzImage</code>, which is the
compressed vmlinux loaded by the bootloader.</p>

<p><img src="/files/aslr/l3.png" alt="image" /></p>

<p>Next, we need to prepare a filesystem image that our compiled kernel
will use. We execute those commands:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir </span>image <span class="o">&amp;&amp;</span> <span class="nb">cd </span>image
<span class="nv">$ </span>wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh <span class="nt">-O</span> create-image.sh
<span class="nv">$ </span><span class="nb">chmod</span> +x create-image.sh
<span class="nv">$ </span>./create-image.sh
</code></pre></div></div>

<p>that will create a disk image based on Debian.</p>

<p><img src="/files/aslr/l4.png" alt="image" /></p>

<p>At this point we have everything ready to run the system. We create a
<code class="language-plaintext highlighter-rouge">./run.sh</code> file into which we write:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>qemu-system-x86_64 <span class="se">\</span>
        <span class="nt">-m</span> 1G <span class="se">\</span>
        <span class="nt">-smp</span> 2 <span class="se">\</span>
        <span class="nt">-gdb</span> tcp::1234 <span class="se">\</span>
        <span class="nt">-kernel</span> <span class="nv">$1</span>/arch/x86/boot/bzImage <span class="se">\</span>
        <span class="nt">-append</span> <span class="s2">"console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0 nokaslr"</span> <span class="se">\</span>
        <span class="nt">-drive</span> <span class="nv">file</span><span class="o">=</span><span class="nv">$2</span>/bullseye.img,format<span class="o">=</span>raw <span class="se">\</span>
        <span class="nt">-net</span> user,host<span class="o">=</span>10.0.2.10,hostfwd<span class="o">=</span>tcp:127.0.0.1:10021-:22 <span class="se">\</span>
        <span class="nt">-net</span> nic,model<span class="o">=</span>e1000 <span class="se">\</span>
        <span class="nt">-enable-kvm</span> <span class="se">\</span>
        <span class="nt">-nographic</span> <span class="se">\</span>
        <span class="nt">-pidfile</span> vm.pid <span class="se">\</span>
        2&gt;&amp;1 | <span class="nb">tee </span>vm.log
</code></pre></div></div>

<p>and we run it with:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">chmod</span> +x run.sh
<span class="nv">$ </span>./run.sh <span class="nb">.</span> image/
</code></pre></div></div>

<p><img src="/files/aslr/l5.png" alt="image" /></p>

<p>After execution we should see a screen with system login, we log in as
the root user, which has no password.</p>

<p><img src="/files/aslr/l6.png" alt="image" /></p>

<p>At this point we can connect from a second terminal using gdb to port
1234 provided by qemu. We run gdb with <code class="language-plaintext highlighter-rouge">$ gdb ./vmlinux</code> and enter the
gdb command <code class="language-plaintext highlighter-rouge">target remote 0:1234</code>.</p>

<p><img src="/files/aslr/l7.png" alt="image" /></p>

<p>At this point we have gdb connected to the Linux kernel that we
compiled, yay! We can execute all the commands we know from debugging
programs running in userspace, like breakpoints, stepping and
nexting. Additionally I use a gdb plugin
<a href="https://github.com/pwndbg/pwndbg">pwndbg</a>, which theoretically is
created with exploit development and reverse engineering in mind,
however I also use it for regular debugging since it makes using gdb
easier and I’m used to it. There are also other plugins like
<a href="https://github.com/hugsy/gef">gef</a>, or
<a href="https://github.com/cyrus-and/gdb-dashboard">gdb-dashboard</a>, which is
more created with regular programmers in mind. I recommend picking one
and installing it according to the instructions in the given plugin’s
README.</p>

<p><img src="/files/aslr/l8.png" alt="image" /></p>

<p>We’re also able to connect to the user inside qemu via ssh, as well as
transfer files through scp (which can be useful e.g. to transfer a
binary that we compile locally but want to execute inside QEMU).</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>scp <span class="nt">-i</span> image/bullseye.id_rsa <span class="nt">-P</span> 10021 <span class="nt">-o</span> <span class="s2">"StrictHostKeyChecking no"</span> ./plik root@localhost:/
<span class="nv">$ </span>ssh <span class="nt">-i</span> image/bullseye.id_rsa <span class="nt">-p</span> 10021 <span class="nt">-o</span> <span class="s2">"StrictHostKeyChecking no"</span> root@localhost
</code></pre></div></div>

<h3 id="deep-dive">Deep-dive</h3>

<p>The function <code class="language-plaintext highlighter-rouge">static int load_elf_binary(struct linux_binprm *bprm)</code>
in the file <code class="language-plaintext highlighter-rouge">fs/binfmt_elf.c</code> is responsible for loading executable
files into memory, and it’s precisely from its fragments that we’ll
begin, as randomization starts right here.</p>

<p>To understand how this works in gdb, we set a breakpoint in the
aforementioned function and will run the program <code class="language-plaintext highlighter-rouge">$ cat
/proc/self/maps</code>, which will display where all memory segments are
mapped.</p>

<h4 id="binary">Binary</h4>

<p>On line 1130 we have code executing for ELF files with <code class="language-plaintext highlighter-rouge">ET_DYN</code> (in
other words, these are binaries compiled with <code class="language-plaintext highlighter-rouge">-pie -fpie</code>). In the if
condition, we additionally check whether our binary has some
“interpreter”. In the case of ELFs, this is the loader/ld-linux.so,
while in the case of executable text files, the interpreter is defined
by the <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>			<span class="k">if</span> <span class="p">(</span><span class="n">interpreter</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* On ET_DYN with PT_INTERP, we do the ASLR. */</span>
				<span class="n">load_bias</span> <span class="o">=</span> <span class="n">ELF_ET_DYN_BASE</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_RANDOMIZE</span><span class="p">)</span>
					<span class="n">load_bias</span> <span class="o">+=</span> <span class="n">arch_mmap_rnd</span><span class="p">();</span>
				<span class="cm">/* Adjust alignment as requested. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">alignment</span><span class="p">)</span>
					<span class="n">load_bias</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">alignment</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">elf_flags</span> <span class="o">|=</span> <span class="n">MAP_FIXED_NOREPLACE</span><span class="p">;</span>
</code></pre></div></div>

<p>The macro <code class="language-plaintext highlighter-rouge">ELF_ET_DYN_BASE</code> equals <code class="language-plaintext highlighter-rouge">0x555555554aaa</code> and defines the
base address (precisely 0x555555554000 after alignment to memory
pages) for PIE loading, to which our program would be loaded if not
for ASLR.  This seemingly random value was most likely chosen as easy
to recognize during debugging - the “555” pattern is characteristic
and immediately indicates a PIE binary. Since we have ASLR enabled,
the line <code class="language-plaintext highlighter-rouge">load_bias += arch_mmap_rnd();</code> is additionally executed,
which adds randomness to the address where our program will be
loaded. Now let’s examine this function.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">arch_mmap_rnd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">arch_rnd</span><span class="p">(</span><span class="n">mmap_is_ia32</span><span class="p">()</span> <span class="o">?</span> <span class="n">mmap32_rnd_bits</span> <span class="o">:</span> <span class="n">mmap64_rnd_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">arch_rnd</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rndbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_RANDOMIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">get_random_long</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">rndbits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">arch_mmap_rnd</code> calls <code class="language-plaintext highlighter-rouge">arch_rnd</code> with the argument
<code class="language-plaintext highlighter-rouge">mmap64_rnd_bits</code> or <code class="language-plaintext highlighter-rouge">mmap32_rnd_bits</code>, depending on whether our
program is 32-bit. The constant <code class="language-plaintext highlighter-rouge">mmap64_rnd_bits</code> equals 28. The
function <code class="language-plaintext highlighter-rouge">arch_rnd</code> generates a 28-bit number for us, then performs a
bit shift (<code class="language-plaintext highlighter-rouge">PAGE_SHIFT</code>) to align the numbers to memory pages, which
have a size of 4KiB. Example numbers that this function will return
are: 0xe14e215000, 0x110feee000, and 0x6eb8eda000.</p>

<p>The generated number is added to the variable <code class="language-plaintext highlighter-rouge">load_bias</code>, which
equals <code class="language-plaintext highlighter-rouge">0x555555554aaa</code>. After adding <code class="language-plaintext highlighter-rouge">0x6eb8eda000</code> to this variable,
it takes the value <code class="language-plaintext highlighter-rouge">0x55c40e42eaaa</code>. The mask <code class="language-plaintext highlighter-rouge">~(alignment - 1)</code>
equals <code class="language-plaintext highlighter-rouge">0xfffffffffffff000</code>, so after the masking operation <code class="language-plaintext highlighter-rouge">load_bias
&amp;= ~(alignment - 1);</code> the variable <code class="language-plaintext highlighter-rouge">load_bias</code> equals
<code class="language-plaintext highlighter-rouge">0x55c40e42e000</code>. After typing <code class="language-plaintext highlighter-rouge">continue</code> in gdb, the cat command
shows us that indeed our program appeared at this location in memory.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@syzkaller:~# <span class="nb">cat</span> /proc/self/maps
55c40e42e000-55c40e430000 r--p 00000000 08:00 12243                      /usr/bin/cat
55c40e430000-55c40e435000 r-xp 00002000 08:00 12243                      /usr/bin/cat
55c40e435000-55c40e438000 r--p 00007000 08:00 12243                      /usr/bin/cat
55c40e438000-55c40e439000 r--p 00009000 08:00 12243                      /usr/bin/cat
55c40e439000-55c40e43a000 rw-p 0000a000 08:00 12243                      /usr/bin/cat
55c448bc7000-55c448be8000 rw-p 00000000 00:00 0                          <span class="o">[</span>heap]
...
</code></pre></div></div>

<h4 id="heap">Heap</h4>

<p>Much lower in the same function, at the very end on line 1330, we have
randomization of the location where the heap beginning will be found.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_brk</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">=</span> <span class="n">ELF_PAGEALIGN</span><span class="p">(</span><span class="n">elf_brk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_RANDOMIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">snapshot_randomize_va_space</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*
		 * If we didn't move the brk to ELF_ET_DYN_BASE (above),
		 * leave a gap between .bss and brk.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">brk_moved</span><span class="p">)</span>
			<span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_brk</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_brk</span> <span class="o">=</span> <span class="n">arch_randomize_brk</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">brk_moved</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>This value is randomized in the function <code class="language-plaintext highlighter-rouge">arch_randomize_brk</code>, which
we’ll examine. The name <code class="language-plaintext highlighter-rouge">brk</code> comes from the fact that the place where
the heap is designated is defined by the system call <code class="language-plaintext highlighter-rouge">brk</code>. The word
“break” here means “boundary” or “breakpoint” - <code class="language-plaintext highlighter-rouge">brk</code> is a pointer in
memory that defines the end of the heap. When a program needs more
memory on the heap, it uses the system call <code class="language-plaintext highlighter-rouge">brk</code> and “moves the
break” higher in memory, thereby increasing the available space.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">arch_randomize_brk</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmap_is_ia32</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">randomize_page</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">,</span> <span class="n">SZ_32M</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">randomize_page</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">,</span> <span class="n">SZ_1G</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">randomize_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">range</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PAGE_ALIGNED</span><span class="p">(</span><span class="n">start</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">range</span> <span class="o">-=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">ULONG_MAX</span> <span class="o">-</span> <span class="n">range</span><span class="p">)</span>
		<span class="n">range</span> <span class="o">=</span> <span class="n">ULONG_MAX</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>

	<span class="n">range</span> <span class="o">&gt;&gt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">range</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">start</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">get_random_long</span><span class="p">()</span> <span class="o">%</span> <span class="n">range</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the function <code class="language-plaintext highlighter-rouge">arch_randomize_brk</code> we call <code class="language-plaintext highlighter-rouge">randomize_page</code> with an
argument depending on whether the program is 32-bit. The function
<code class="language-plaintext highlighter-rouge">randomize_page</code> generates a number in the range from start to
start+range (not inclusive). So we’ll generate a number in the range
from mm-&gt;brk (which equals the address of the memory page after which
our loaded program ends) to mm-&gt;brk+1GiB.</p>

<p>So it might seem that we have an additional 1 Gigabyte (2^30) of
randomness. However, it should be remembered that this address is
aligned to a memory page (4KiB, i.e., 2^12), so 12 bits are
subtracted.  Assuming we know the binary address but don’t know the
heap address, we have 18 (30-12) bits of entropy. This isn’t
particularly much and is a certain weakness in ASLR on Linux. This
fact was exploited in this year’s edition of the Break The Syntax
hacking competition in one of my tasks <code class="language-plaintext highlighter-rouge">poniponi-virus</code>, which was one
of the more difficult tasks. You can see a write-up
<a href="https://poniponiponiponiponiponiponiponiponi.github.io/ctf/pwn/c/rust/risc-v/2025/05/16/Challenges-I-Wrote-For-BtS-CTF-2025.html">here</a>.</p>

<h4 id="stack">Stack</h4>

<p>We determine the stack address on line 1020 in the function
<code class="language-plaintext highlighter-rouge">load_elf_binary</code>. Right after the base address to which our shared
libraries will be loaded is determined (which will be discussed
later).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="cm">/* Do this so that we can load the interpreter, if need be.  We will
	   change some of these later */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">setup_arg_pages</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="n">randomize_stack_top</span><span class="p">(</span><span class="n">STACK_TOP</span><span class="p">),</span>
				 <span class="n">executable_stack</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_dentry</span><span class="p">;</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">setup_arg_pages</code> takes as one of its arguments the top
of the stack. It should be remembered that in the case of x64
architecture, the stack grows downward (i.e., toward lower addresses),
so we’re actually determining the beginning of the stack. The macro
<code class="language-plaintext highlighter-rouge">STACK_TOP</code> equals 0x7ffffffff000.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define __STACK_RND_MASK(is32bit) ((is32bit) ? 0x7ff : 0x3fffff)
#define STACK_RND_MASK __STACK_RND_MASK(mmap_is_ia32())
</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">randomize_stack_top</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_top</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">random_variable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_RANDOMIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">random_variable</span> <span class="o">=</span> <span class="n">get_random_long</span><span class="p">();</span>
		<span class="n">random_variable</span> <span class="o">&amp;=</span> <span class="n">STACK_RND_MASK</span><span class="p">;</span>
		<span class="n">random_variable</span> <span class="o">&lt;&lt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_STACK_GROWSUP
</span>	<span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack_top</span><span class="p">)</span> <span class="o">+</span> <span class="n">random_variable</span><span class="p">;</span>
<span class="cp">#else
</span>	<span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack_top</span><span class="p">)</span> <span class="o">-</span> <span class="n">random_variable</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>The macro <code class="language-plaintext highlighter-rouge">STACK_RND_MASK</code> equals 0x3fffff, so we generate a number
consisting of 22 random bits aligned to a memory page. After this, we
subtract this number from the address that would be the top of the
stack if not for ASLR.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">setup_arg_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_top</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">executable_stack</span><span class="p">)</span>
<span class="cp">#else
</span>	<span class="n">stack_top</span> <span class="o">=</span> <span class="n">arch_align_stack</span><span class="p">(</span><span class="n">stack_top</span><span class="p">);</span>
	<span class="n">stack_top</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack_top</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">stack_top</span> <span class="o">&lt;</span> <span class="n">mmap_min_addr</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">unlikely</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;=</span> <span class="n">stack_top</span> <span class="o">-</span> <span class="n">mmap_min_addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">stack_shift</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">stack_top</span><span class="p">;</span>

	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-=</span> <span class="n">stack_shift</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_start</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>In the function <code class="language-plaintext highlighter-rouge">setup_arg_pages</code> we additionally call the function
<code class="language-plaintext highlighter-rouge">arch_align_stack</code>, which adds additional random less-significant bits
to our stack. As a result, the stack won’t start at the beginning/end
of some memory page, but in the middle. The rest of the page will
simply be filled with zeros. This two-level stack randomization
(randomization at the page level + fine randomization within the page)
ensures both significant entropy and proper alignment for instructions
requiring specific alignment.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">arch_align_stack</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;</span> <span class="n">ADDR_NO_RANDOMIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">randomize_va_space</span><span class="p">)</span>
		<span class="n">sp</span> <span class="o">-=</span> <span class="n">get_random_u32_below</span><span class="p">(</span><span class="mi">8192</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the function <code class="language-plaintext highlighter-rouge">arch_align_stack</code> we can see that we generate a
number less than 8192 (0x2000). So we have 13 random bits. After this,
before returning this number, we mask it with ~0xf, i.e., we remove 4
bits of randomness, ultimately obtaining 9 bits of
randomness. However, one bit overlaps with another bit from the
previously generated number, so in practice we have about 30 bits of
randomness (22+9-1).</p>

<h4 id="shared-libraries-and-mmap">Shared libraries and mmap</h4>

<p>In the function <code class="language-plaintext highlighter-rouge">load_elf_binary</code> on line 1016 we have the function
<code class="language-plaintext highlighter-rouge">setup_new_exec</code>, which calls <code class="language-plaintext highlighter-rouge">arch_pick_mmap_layout</code>, which in turn
calls <code class="language-plaintext highlighter-rouge">arch_pick_mmap_base</code>. In this function we determine the base
address for dynamically loaded shared libraries (such as <code class="language-plaintext highlighter-rouge">libc.so.6</code>)
and addresses returned by the mmap system call.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">arch_pick_mmap_layout</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">rlim_stack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmap_is_legacy</span><span class="p">())</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">MMF_TOPDOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">MMF_TOPDOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">arch_pick_mmap_base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_legacy_base</span><span class="p">,</span>
			<span class="n">arch_rnd</span><span class="p">(</span><span class="n">mmap64_rnd_bits</span><span class="p">),</span> <span class="n">task_size_64bit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			<span class="n">rlim_stack</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*
 * This function, called very early during the creation of a new
 * process VM image, sets up which VM layout function to use:
 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">arch_pick_mmap_base</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">legacy_base</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">random_factor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">task_size</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">rlim_stack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">legacy_base</span> <span class="o">=</span> <span class="n">mmap_legacy_base</span><span class="p">(</span><span class="n">random_factor</span><span class="p">,</span> <span class="n">task_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmap_is_legacy</span><span class="p">())</span>
		<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="o">*</span><span class="n">legacy_base</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">mmap_base</span><span class="p">(</span><span class="n">random_factor</span><span class="p">,</span> <span class="n">task_size</span><span class="p">,</span> <span class="n">rlim_stack</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The variable <code class="language-plaintext highlighter-rouge">*base</code> is our base address and the value returned by the
function <code class="language-plaintext highlighter-rouge">mmap_base</code> is assigned to it.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">mmap_base</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rnd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">task_size</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">rlim_stack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gap</span> <span class="o">=</span> <span class="n">rlim_stack</span><span class="o">-&gt;</span><span class="n">rlim_cur</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pad</span> <span class="o">=</span> <span class="n">stack_maxrandom_size</span><span class="p">(</span><span class="n">task_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">stack_guard_gap</span><span class="p">;</span>

	<span class="cm">/* Values close to RLIM_INFINITY can overflow. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gap</span> <span class="o">+</span> <span class="n">pad</span> <span class="o">&gt;</span> <span class="n">gap</span><span class="p">)</span>
		<span class="n">gap</span> <span class="o">+=</span> <span class="n">pad</span><span class="p">;</span>

	<span class="cm">/*
	 * Top of mmap area (just below the process stack).
	 * Leave an at least ~128 MB hole with possible stack randomization.
	 */</span>
	<span class="n">gap</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">gap</span><span class="p">,</span> <span class="n">SIZE_128M</span><span class="p">,</span> <span class="p">(</span><span class="n">task_size</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">task_size</span> <span class="o">-</span> <span class="n">gap</span> <span class="o">-</span> <span class="n">rnd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The argument <code class="language-plaintext highlighter-rouge">rnd</code> equals the result of <code class="language-plaintext highlighter-rouge">arch_rnd(mmap64_rnd_bits)</code>,
which was discussed when examining how the binary is randomized and
works exactly the same way. As a reminder, the value returned by this
function gives us 28 bits of entropy.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned long task_size_64bit(int full_addr_space)
{
	return full_addr_space ? TASK_SIZE_MAX : DEFAULT_MAP_WINDOW;
}
</code></pre></div></div>

<p>The argument <code class="language-plaintext highlighter-rouge">task_size</code> equals the result of <code class="language-plaintext highlighter-rouge">task_size_64bit(0)</code>,
i.e., <code class="language-plaintext highlighter-rouge">DEFAULT_MAP_WINDOW</code> (0x7ffffffff000), since the function is
called with argument 0.</p>

<p>The base address is determined only once during program loading and
all libraries/mmap system calls depend on it! In the function
<code class="language-plaintext highlighter-rouge">unmapped_area_topdown</code> in the file <code class="language-plaintext highlighter-rouge">./mm/vma.c</code> we determine
subsequent addresses returned by mmap and loaded libraries. We won’t
examine this function anymore, as it’s quite complicated and considers
many edge cases.</p>

<p>As we can see in the images below:</p>

<p><img src="/files/aslr/mmap.png" alt="image" /></p>

<p><img src="/files/aslr/cat.png" alt="image" /></p>

<p>for the execution of the command <code class="language-plaintext highlighter-rouge">cat /proc/self/maps</code>, the function
<code class="language-plaintext highlighter-rouge">mmap_base</code> will return 0x7f1c82d07000. This is an address equal to
the end of the last memory segment appearing before the stack. In
practice, it turns out that each time the function
<code class="language-plaintext highlighter-rouge">unmapped_area_topdown</code> returns the highest possible address that is
lower than the previous one, so all memory segments “touch each other
and there are no gaps”. As a result, if an attacker knows one address
(e.g., a leak of the address of some anonymous memory call returned by
the <code class="language-plaintext highlighter-rouge">mmap</code> system call), they know all other addresses (e.g., the
address of the standard libc library), because the relative offset
remains constant. This is a major weakness in how Linux implements
ASLR.</p>

<h2 id="comparison-with-other-operating-systems">Comparison with other operating systems</h2>
<p>An interesting fact is that ASLR in Linux, unlike Windows and macOS,
is the only one that has equal probability distribution
everywhere. Research conducted in the paper <a href="https://arxiv.org/abs/2408.15107">“The Illusion of
Randomness”</a> compared randomness
(amount of absolute and conditional entropy bits, as well as
distribution) in different operating systems.  This is how the
distribution looks on Linux:</p>

<p><img src="dist_linux.png" alt="image" /></p>

<p>and this is how it looks on Windows and macOS:</p>

<p><img src="dist_win.png" alt="image" /></p>

<p><img src="dist_mac.png" alt="image" /></p>

<p>I encourage the curious to read the original paper, as it is very
interesting.</p>

<h2 id="summary">Summary</h2>
<p>ASLR in the Linux kernel, despite being implemented in a relatively
simple and understandable way, has several significant security
weaknesses. The most important of these are low heap entropy (18 bits)
and deterministic layout of shared libraries, where knowing one
address allows inferring all the others.  The implementation is based
on several key functions: <code class="language-plaintext highlighter-rouge">arch_mmap_rnd()</code> for randomization of
binaries and libraries (28 bits of entropy), <code class="language-plaintext highlighter-rouge">arch_randomize_brk()</code>
for the heap (18 bits of entropy), and <code class="language-plaintext highlighter-rouge">randomize_stack_top()</code> and
<code class="language-plaintext highlighter-rouge">arch_align_stack()</code> for the stack (about 30 bits of entropy
combined). Each of these mechanisms works independently during program
loading.</p>

<h2 id="źródła">Źródła</h2>
<ul>
  <li>https://arxiv.org/abs/2408.15107</li>
  <li>https://whitehats.pwr.edu.pl/research/buffer-overflow/</li>
  <li>https://sam4k.com/linternals-virtual-memory-part-1/</li>
  <li>https://vccolombo.github.io/cybersecurity/linux-kernel-qemu-setup/</li>
  <li>https://en.wikipedia.org/wiki/Address_space_layout_randomization</li>
  <li>https://0x434b.dev/an-introduction-to-address-space-layout-randomization-aslr-in-linux/
(a very similar article but has some errors and not everything is
showed)</li>
  <li>https://www.kernel.org/</li>
  <li>https://github.com/pwndbg/pwndbg</li>
</ul>

  </div><a class="u-url" href="/c/linux/alsr/2025/06/13/Linux-Internals-How-ASLR-REALLY-Works.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">poni&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">poni&#39;s blog</li><li><a class="u-email" href="mailto:poniponiponiponiponiponiponiponiponiponi@protonmail.com">poniponiponiponiponiponiponiponiponiponi@protonmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/poniponiponiponiponiponiponiponiponi"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">poniponiponiponiponiponiponiponiponi</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>My tech blog where I write about things I find interesting. Mostly low level programming, linux and ctf competitions.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
